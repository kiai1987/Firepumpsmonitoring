<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; connect-src 'self' wss:; script-src 'self' https://unpkg.com;">
    <title>Secure Fire Pump Monitoring</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Styles remain similar to previous version */
        :root {
            --primary: #00b4d8;
            --secondary: #0077b6;
            --background: #0a1929;
            --card-bg: #132f4c;
            --danger: #e63946;
            --warning: #ffb703;
            --success: #2a9d8f;
            --text-light: #e0e0e0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background);
            color: var(--text-light);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }

        /* ... (keep previous styles) ... */
    </style>
</head>
<body>
    <div class="container">
        <!-- Header and dashboard structure remains similar -->
        <!-- ... (keep previous HTML structure) ... -->
    </div>

    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <script>
        // Secure configuration
        const SECURE_CONFIG = {
            mqtt: {
                servers: [
                    "wss://your-secure-server-1:8884/mqtt",
                    "wss://your-secure-server-2:8884/mqtt"
                ],
                credentials: {
                    username: sessionStorage.getItem('mqtt_user') || 'default_user',
                    password: sessionStorage.getItem('mqtt_pass') || 'default_pass'
                },
                topic: 'fire-pump/status'
            },
            session: {
                timeout: 900000, // 15 minutes
                refreshInterval: 300000 // 5 minutes
            }
        };

        let mqttClient = null;
        let lastUpdate = Date.now();
        let sessionTimer;

        // Secure initialization
        function init() {
            validateSession();
            setupEventListeners();
            connectMQTT();
            startSessionTimer();
        }

        function validateSession() {
            const authToken = sessionStorage.getItem('authToken');
            if (!authToken || !verifyToken(authToken)) {
                logout();
            }
        }

        function verifyToken(token) {
            // Implement proper JWT validation with server-side verification
            return true; // Placeholder for actual validation
        }

        function connectMQTT() {
            if (mqttClient) mqttClient.end();

            mqttClient = mqtt.connect(SECURE_CONFIG.mqtt.servers[0], {
                clientId: 'web-client-' + crypto.randomUUID(),
                username: SECURE_CONFIG.mqtt.credentials.username,
                password: SECURE_CONFIG.mqtt.credentials.password,
                clean: true,
                reconnectPeriod: 5000,
                rejectUnauthorized: true
            });

            mqttClient.on('connect', () => {
                console.log('Secure MQTT connection established');
                mqttClient.subscribe(SECURE_CONFIG.mqtt.topic, { qos: 1 }, (err) => {
                    if (err) console.error('Secure subscription failed:', err);
                });
            });

            mqttClient.on('message', (topic, message) => {
                try {
                    const data = sanitizeInput(JSON.parse(message.toString()));
                    lastUpdate = Date.now();
                    updateUI(data);
                    checkAlarms(data);
                } catch (error) {
                    console.error('Secure message handling failed:', error);
                }
            });

            mqttClient.on('error', (err) => {
                console.error('Secure MQTT error:', err);
                handleSecurityEvent('mqtt_error', err.message);
            });
        }

        function sanitizeInput(data) {
            // Implement input validation and sanitization
            const schema = {
                JP: 'boolean',
                JPT: 'boolean',
                // ... other expected fields
            };

            for (const [key, type] of Object.entries(schema)) {
                if (typeof data[key] !== type) {
                    handleSecurityEvent('data_validation_failed', key);
                    throw new Error('Invalid data format');
                }
            }
            return data;
        }

        function handleSecurityEvent(type, details) {
            console.warn(`Security event: ${type}`, details);
            // Implement proper security event logging
        }

        function updateUI(data) {
            // Implement secure UI updates with DOM sanitization
            const pressure = parseFloat(data.WP);
            document.getElementById('water-pressure').textContent = 
                Number.isNaN(pressure) ? '--' : pressure.toFixed(1);
            
            // ... rest of UI updates ...
        }

        function handleModeChange(pumpType, mode) {
            if (![0, 1, 2].includes(parseInt(mode))) {
                handleSecurityEvent('invalid_input', `Mode: ${mode}`);
                return;
            }
            
            const topic = `fire-pump/${pumpType}/mode`;
            const payload = JSON.stringify({
                pump: pumpType,
                mode: mode,
                timestamp: Date.now(),
                signature: createSignature(pumpType + mode)
            });

            mqttClient.publish(topic, payload, { qos: 1 }, (err) => {
                if (err) handleSecurityEvent('publish_error', err.message);
            });
        }

        function createSignature(data) {
            // Implement HMAC signature for critical commands
            return 'secure_signature'; // Placeholder for actual implementation
        }

        function startSessionTimer() {
            sessionTimer = setInterval(() => {
                if (Date.now() - lastUpdate > SECURE_CONFIG.session.timeout) {
                    logout();
                }
            }, 10000);
        }

        function logout() {
            clearInterval(sessionTimer);
            sessionStorage.clear();
            if (mqttClient) {
                mqttClient.end();
                mqttClient = null;
            }
            window.location.href = '/login';
        }

        // Initialize after DOM load
        window.addEventListener('DOMContentLoaded', () => {
            if (window.self === window.top) { // Prevent iframe embedding
                init();
            } else {
                document.body.innerHTML = '<h1>Embedding not allowed</h1>';
            }
        });
    </script>
</body>
</html>